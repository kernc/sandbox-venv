#!/bin/sh
# sandbox-venv: container sandbox venv wrapper
# Wraps all .venv/bin entry‑points so they run under bubblewrap.
# Also re‑wrap any new scripts post installation by pip etc.
# shellcheck disable=SC2317
set -eu

for arg; do case "$arg" in -h|-\?|--help) echo "Usage: ${0##*/} [VENV_DIR] [BWRAP_OPTS]    # Dir defaults to .venv"; exit ;; esac; done

warn () { echo "sandbox-venv: $*" >&2; }
alias realpath='realpath --no-symlinks'

command -v bwrap >/dev/null || { warn 'Required command bwrap missing; apt install bubblewrap ?' ; exit 1; }

# Filter args s.t. $@ == bwrap extra args
venv='.venv'; [ $# -eq 0 ] || case "$1" in -*) ;; *) venv="$(realpath "$1")"; shift ;; esac

cd "$venv/bin" || { warn 'Error: Missing venv. Make a venv: python -m venv .venv'; exit 1; }
cd "../.."  # I.e. the project dir
venv="${venv##*/}"
bin="$venv/bin"
[ -d "$bin" ] || { warn 'Assertion failed'; exit 2; }
this_script="$(command -v "$0")"
[ -f "$this_script" ] || { warn 'Assertion failed'; exit 3; }

is_python_shebang () {
    shebang_line="$(head -n1 "$1" | tr -d '\0')"
    test "${shebang_line#\#!}" = "$(realpath "${1%/*}/python")"
}
is_already_wrapped () { head -n2 "$1" | grep -q '^# sandbox-venv'; }
export_func () { awk "/^$1 \(\) {/,/^}|; }\$/" "$0"; }
extract_segment () {
    segment="$1"; shift
    awk "/^# CUT HERE / { c++; next } c==$segment" "$this_script" |
        sed -E "s|^_BWRAP_DEFAULT_ARGS=.*|_BWRAP_DEFAULT_ARGS=\"$*\"|"
}

wrap_pip () {
    out="$1"; shift
    extract_segment 1 "$@" > "$out"
    printf '%s\n%s\n%s\n' \
            "$(export_func split_args_by_lf)" \
            "$(export_func is_python_shebang)" \
            "$(export_func is_already_wrapped)" |
        sed -i -E '/^# AUX_FUNCS.*/{
            r /dev/stdin
            d}' "$out"
}

wrap_executable () {
    out="$1" executable="$2"; shift 2
    extract_segment 2 "$@" > "$out"
    sed -i -E "s|^EXECUTABLE=.*|EXECUTABLE='${executable##*/}'|" "$out"
}

add_bin_shell () {
    cat > "$1" <<EOF
#!/bin/env ${1%/*}/python
import shutil
import subprocess
import sys
if __name__ == '__main__':
    shell = shutil.which('/bin/bash') or '/bin/sh'
    sys.exit(subprocess.run([shell, *sys.argv[1:]]).returncode)
EOF
}

wrap_all () (
    for file in "$bin"/*; do
        # shellcheck disable=SC2015
        [ -f "$file" ] && [ -x "$file" ] || continue
        ! is_already_wrapped "$file" || continue
        case "${file##*/}" in pip*) ;; *) ! is_python_shebang "$file" || continue ;; esac  # Skip if wrapped transitively, except pip
        # shellcheck disable=SC2015
        [ -L "$file" ] && case "$(readlink "$file")" in /*) ;; *) continue ;; esac || true  # Skip relative symlinks

        unsafe_file="$bin/.unsafe_${file##*/}"
        if ! is_already_wrapped "$file"; then
            mv -v "$file" "$unsafe_file"
        fi

        case "${file##*/}" in
            pip|pip3*) wrap_pip "$file" "$@" ;;
            *) wrap_executable "$file" "$unsafe_file" "$@" ;;
        esac
        chmod +x "$file"
        echo "$file"
    done

    file="$(realpath "$bin/shell")"
    add_bin_shell "$file"
    chmod +x "$file"
    echo "$file"
)

wrap_all "$@"
exit 0


# CUT HERE ------------------- Appendix 1: sandbox-venv _wrapper_pip.sh script
#!/bin/sh
# sandbox-venv: Secure container sandbox venv wrapper (GENERATED CODE)
# pip wrapper: Re-run sandbox-venv after every pip installation
set -u
alias realpath='realpath --no-symlinks'

venv="$(realpath "${0%/*}/..")"

_BWRAP_DEFAULT_ARGS=

# AUX_FUNCS: Auxiliary functions get inserted here

BWRAP_ARGS="$(split_args_by_lf "$_BWRAP_DEFAULT_ARGS")
--bind
$venv
$venv
$(split_args_by_lf "${BWRAP_ARGS-}")" \
    "$venv/bin/.unsafe_${0##*/}" "$@"
pip_return_status=$?

new_binaries="$(
    for file in "$venv/bin"/*; do
        [ -L "$file" ] || [ ! -x "$file" ] ||
            [ "${file##*/}" = 'shell' ] ||
            is_already_wrapped "$file" ||
            is_python_shebang "$file" ||
            printf ' %s' "${file##*/}"
    done)"

if [ "$new_binaries" ]; then
    # Reset shebang to the one outside the sandbox
    for exe in $new_binaries; do sed -i "1s,/bin/.unsafe_,/bin/," "$venv/bin/$exe"; done

    if [ "$(command -v sandbox-venv)" ]; then
        echo "sandbox-venv: New binaries found:$new_binaries. Re-running sandbox-venv ..."
        sandbox-venv "$venv"
    else echo "WARNING: sandbox-venv not in \$PATH. Cannot sandbox/patch new executables:$new_binaries. Rerun sandbox-venv on this venv to stay secure."
    fi
fi

exit $pip_return_status


# CUT HERE ------------------- Appendix 2: sandbox-venv _wrapper_exe.sh script
#!/bin/sh
# sandbox-venv: Secure container sandbox venv wrapper (GENERATED CODE)
set -eu

alias realpath='realpath --no-symlinks'
warn () { echo "sandbox-venv/wrapper: $*" >&2; }

venv="$(realpath "${0%/*}/..")"

# Quote args with spaces
format_args () {
    for arg in "$@"; do case "$arg" in
        $venv/*) printf "%s " "${venv##*/}/${arg#"$venv/"}" ;;
        *\ *) printf "'%s' " "$arg" ;;
        *) printf "%s " "$arg" ;;
    esac; done
}
formatted_cmdline="python $(format_args "$@")"

EXECUTABLE="${1:-/usr/bin/python3}"
_BWRAP_DEFAULT_ARGS=

[ -e "$venv/bin/python3" ]  # Assertion

# Expose these binaries
executables="
    /usr/bin/python3

    /usr/bin/git
    /usr/bin/git-receive-pack
    /usr/bin/git-upload-archive
    /usr/bin/git-upload-pack

    /bin/bash
    /bin/env
    /bin/ls
    /bin/sh
    /bin/uname
    "

case $- in *x*) xtrace=-x ;; *) xtrace=+x ;; esac; set +x

# Collect binaries' lib dependencies
lib_deps () {
    { readelf -l "$1" 2>/dev/null || true; } | awk '/interpreter/ {print $NF}' | tr -d '[]'
    { ldd "$1" 2>/dev/null || true; } | awk '/=>/ { print $3 }' | { grep -E '^/' || true; }
}
collect="$executables"
for exe in $executables; do
    collect="$collect
        $(lib_deps "$exe")"
done

# Collect lib deps from venv/lib/*.so
root_so_lib_dirs="
    /usr/lib/python3*/lib-dynload
    /usr/lib64/python3*/lib-dynload"
# XXX: If some `git` tools are failing, add $(find /usr/lib/git-core -type f)
for exe in $(find "$venv/lib" $root_so_lib_dirs -name '*.so' 2>/dev/null || true); do
    collect="$collect
        $(lib_deps "$exe")"
done

# Explicit Python deps we know of
py_libs="
    /usr/include/python3*
    /usr/lib/python3*
    /usr/lib64/python3*
    /usr/local/lib/python3*"
git_libs="
    /usr/lib*/git-core
"
ro_bind_extra="
    /etc/hosts
    /etc/resolv.conf

    /etc/ld.so.cache
    /etc/os-release
    /usr/share/locale
    /usr/share/zoneinfo

    /usr/share/ca-certificates*
    /etc/pki
    /etc/ssl
    /usr/share/pki*
    "

collect="
    $collect
    $ro_bind_extra
    $git_libs
    $py_libs"

# Filter collect, warn on non-existant paths, unique sort, cull.
# Use separate for-loop to expand globstar.
prev="sandbox@"
collect="$(
    # Split only on newline
    for path in $collect; do
        path="$(printf '%s' "$path" | sed -r 's/^ +//;s/ +$//')"
        [ -e "$path" ] ||
            # Don't warn for globstar paths as they are allowed to not match
            case "$path" in *\**) continue ;; *) warn "Warning: missing $path"; continue ;; esac
        echo "$path"
    done |
    sort -u |
    # If collected paths contain /foo/ and /foo/bar,
    # keep only /foo since it covers both
    while IFS= read -r path; do
        case $path in "$prev"/*) continue;; esac
        echo "$path"; prev="$path"
    done)"

split_args_by_lf () {
    lf='
'
    printf '%s' "$1" | case "$1" in *$lf*) cat ;; *) tr ' ' '\n' ;; esac; }

# Begins constructing args for bwrap, in reverse
# (later args in command line override prior ones)
IFS='
'  # Split args only on newline
# shellcheck disable=SC2046
set -- $(split_args_by_lf "$_BWRAP_DEFAULT_ARGS") \
       $(split_args_by_lf "${BWRAP_ARGS:-}") \
       "${0%/*}/$EXECUTABLE" "$@"

for path in $collect; do set -- --ro-bind "$path" "$path" "$@"; done

# RW-bind project dir (dir that contains .venv)
# but RO-bind some dirs like .venv and git
proj_dir="$(realpath "$venv/..")"
ro_bind_pwd_extra="
    ${venv##*/}
    .git"
for path in $ro_bind_pwd_extra; do
    [ ! -e "$proj_dir/$path" ] || set -- --ro-bind "$proj_dir/$path" "$proj_dir/$path" "$@"
done
set -- --bind "$proj_dir" "$proj_dir" "$@"

# RW bind cache dirs for downloads etc.
home="${HOME:-"/home/$USER"}"
pip_cache="$home/${XDG_CACHE_HOME:-.cache}/pip"
mkdir -p "$venv/cache" "$pip_cache"
mkdir -p "$venv/cache/pip" &&
    echo "This is an artefact of Bubblewrap bind mounting. Real pip cache is in \$HOME/.cache/pip" \
    > "$venv/cache/pip/note.txt"
set -- --bind "$venv/cache" "$home/.cache" \
       --bind "$pip_cache" "$home/.cache/pip" "$@"

# Pass our own redacted copy of env
for var in $(env | grep -E '^(USER|LOGNAME|UID|PATH|TERM|LANGUAGE|LANG|LC_.*?|HOSTNAME)='); do
    set -- --setenv "${var%%=*}" "${var#*=}" "$@"
done

set $xtrace

warn "exec bwrap [...] $formatted_cmdline"

uid="$(id -u)"
cwd="$(pwd)"

[ ! "${VERBOSE:-${verbose:-}}" ] || set -x

# shellcheck disable=SC2086
exec bwrap \
    --dir /tmp \
    --dir "/run/user/$uid" \
    --dir "$cwd" \
    --chdir "$cwd" \
    --proc /proc \
    --dev /dev \
    --clearenv \
    --unshare-all \
    --share-net \
    --new-session \
    --die-with-parent \
    --setenv PS1 '\u @ \h \$ ' \
    --setenv HOME "$home" \
    --setenv USER "user" \
    --setenv VIRTUAL_ENV "$venv" \
    "$@"

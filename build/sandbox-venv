#!/bin/sh
# sandbox-venv: container sandbox venv wrapper
# Wraps all .venv/bin entry‑points so they run under bubblewrap.
# Also re‑wrap any new scripts post installation by pip etc.
# shellcheck disable=SC2317
set -eu

for arg; do case "$arg" in -h|-\?|--help) echo "Usage: ${0##*/} [VENV_DIR] [BWRAP_OPTS]    # Dir defaults to .venv"; exit ;; esac; done

warn () { echo "sandbox-venv: $*" >&2; }
alias realpath='realpath --no-symlinks'

command -v bwrap >/dev/null || { warn 'Required command bwrap missing; apt install bubblewrap ?' ; exit 1; }

# Filter args s.t. $@ == bwrap extra args
venv='.venv'; [ $# -eq 0 ] || case "$1" in -*) ;; *) venv="$(realpath "$1")"; shift ;; esac

cd "$venv/bin" || { warn 'Error: Missing venv. Make a venv: python -m venv .venv'; exit 1; }
cd "../.."
HOME="$(pwd)"  # I.e. the project dir
venv="${venv##*/}"
bin="$venv/bin"
[ -d "$bin" ] || { warn 'Assertion failed'; exit 2; }
this_script="$0"
[ -f "$this_script" ] || this_script="$(command -v "$this_script")"
[ -f "$this_script" ] || { warn 'Assertion failed'; exit 3; }

is_python_shebang () {
    shebang_line="$(head -n1 "$1" | tr -d '\0')"
    test "${shebang_line#\#!}" = "$(realpath "$bin/python")"
}
is_already_wrapped () { head -n2 "$1" | grep -q '^# sandbox-venv'; }
export_func () { awk "/^$1 \(\) {/,/^}|; }\$/" "$0"; }

wrap_pip () {
    cat >"$1" <<EOF
#!/bin/sh
# sandbox-venv: container sandbox venv wrapper (GENERATED CODE)
# pip wrapper: Re-run sandbox-venv.sh after every pip invocation
set -u
alias realpath='realpath --no-symlinks'

bin="\$(realpath --relative-to "\${0%/*}/../.." "\${0%/*}")"
venv="\$(realpath "\$bin/..")"
home='/home/user'

BWRAP_ARGS="--bind \$venv \$home/\${venv##*/}" \
    "\$bin/.unsafe_${1##*/}" "\$@"
pip_return_status=\$?

$(export_func is_python_shebang)
$(export_func is_already_wrapped)

new_binaries="\$(
    for file in "\$bin"/*; do
        [ -L "\$file" ] || [ ! -x "\$file" ] ||
            is_already_wrapped "\$file" ||
            is_python_shebang "\$file" ||
            printf ' %s' "\${file##*/}"
    done)"

if [ "\$new_binaries" ]; then
    # Reset shebang to the one outside the sandbox
    for exe in \$new_binaries; do
        sed -i -e "1s|\$home/\${venv##*/}/bin/.unsafe_|\$venv/bin/|" "\$venv/bin/\$exe"
    done
    if [ "\$(command -v sandbox-venv)" ]; then
        echo "sandbox-venv: New binaries found:\$new_binaries. Re-running sandbox-venv ..."
        sandbox-venv "\$venv"
    else echo "WARNING: sandbox-venv not in \\\$PATH. Cannot sandbox/patch new executables:\$new_binaries. Rerun sandbox-venv on this venv to stay secure."
    fi
fi

exit \$pip_return_status
EOF
}

wrap_executable () {
    bin_file="$1" executable="$2"; shift 2
    awk '/^# CUT HERE/{p=1; next} p' "$this_script" |
        sed -E \
               -e "s|^EXECUTABLE=.*|EXECUTABLE='${executable##*/}'|" \
               -e "s|^_BWRAP_DEFAULT_ARGS=.*|_BWRAP_DEFAULT_ARGS=\"$*\"|" \
        > "$bin_file"
    grep -q 'GENERATED CODE' "$bin_file"  # Assertion
}

wrap_all () (
    for file in "$bin"/*; do
        # shellcheck disable=SC2015
        [ -f "$file" ] && [ -x "$file" ] || continue
        ! is_already_wrapped "$file" || continue
        case "${file##*/}" in pip*) ;; *) ! is_python_shebang "$file" || continue ;; esac  # Skip if wrapped transitively, except pip
        # shellcheck disable=SC2015
        [ -L "$file" ] && case "$(readlink "$file")" in /*) ;; *) continue ;; esac || true  # Skip relative symlinks

        unsafe_file="$bin/.unsafe_${file##*/}"
        if ! is_already_wrapped "$file"; then
            mv -v "$file" "$unsafe_file"
        fi

        case "${file##*/}" in
            pip|pip3*) wrap_pip "$file" "$@" ;;
            *) wrap_executable "$file" "$unsafe_file" "$@" ;;
        esac
        chmod +x "$file"
        echo "$file"
    done
)

wrap_all "$@"
exit 0

# CUT HERE ------------------------ Appendix I: sandbox-venv wrapper.sh script
#!/bin/sh
# sandbox-venv: container sandbox venv wrapper (GENERATED CODE)
set -eu
set -x
alias realpath='realpath --no-symlinks'
warn () { echo "sandbox-venv/wrapper: $*" >&2; }

VENV="$(realpath "${0%/*}/..")"
EXECUTABLE="${1:-/usr/bin/python}"
_BWRAP_DEFAULT_ARGS=

home='/home/user'

[ -e "$VENV/bin/python" ]  # Assertion

# Expose these binaries
executables="
    /usr/bin/python
    /bin/env
    /bin/ls
    /bin/bash
    /bin/sh"

case $- in *x*) xtrace=-x ;; *) xtrace=+x ;; esac; set +x

# Collect binaries' lib dependencies
lib_deps () {
    readelf -l "$1" | awk '/interpreter/ {print $NF}' | tr -d '[]'
    ldd "$1" | awk '/=>/ { print $3 }' | grep -E '^/'
}
collect="$executables"
for exe in $executables; do
    collect="$collect
        $(lib_deps "$exe")"
done

# Explicit Python dependencies from Firejail
# TODO: Get lib deps from venv/lib/*.so
py_libs="
    /usr/include/python3*
    /usr/lib/python3*
    /usr/lib64/python3*
    /usr/local/lib/python3*
    /usr/share/python3*
    /usr/lib/*/libreadline.so*
    /usr/lib/**/libreadline.so*
    /usr/lib/**/libssl.so*
    /usr/lib/**/libcrypto.so*
    "
ro_bind_extra="
    /etc/resolv.conf
    /usr/share/ca-certificates
    /etc/pki
    /etc/ssl
    /usr/share/pki
    "
filter_existing_paths() { for p in $1; do [ ! -e "$p" ] || echo "$p"; done; }
ro_bind_extra="$(filter_existing_paths "$ro_bind_extra")"

collect="
    $collect
    $ro_bind_extra
    $py_libs"

# Filter collect, warn on non-existant paths, unique sort, cull.
# Use separate for-loop to expand globstar.
prev="sandbox@"
collect="$(
    for path in $collect; do
        [ -e "$path" ] ||
            # Don't warn for globstar paths as they are allowed to not match
            case "$path" in *\**) continue ;; *) warn "Warning: missing $path"; continue ;; esac
        echo "$path"
    done |
    sort -u |
    while IFS= read -r path; do
        case $path in "$prev"/*) continue;; esac
        echo "$path"; prev="$path"
    done)"

args=""; for path in $collect; do args="$args --ro-bind $path $path"; done

# RW-bind project dir (dir that contains .venv)
args="$args --bind $(realpath "$VENV/..") $home"

# but RO some dirs like .venv and git
ro_bind_pwd_extra="
    ${VENV##*/}
    .git"
for path in $ro_bind_pwd_extra; do
    [ ! -e "$VENV/../$path" ] || args="$args --ro-bind $(realpath "$VENV/../$path") $home/$path"
done

# RW bind cache dir for downloads etc.
pip_cache="${HOME:-"/home/$USER"}/.cache/pip"
mkdir -p "$VENV/cache"
mkdir -p "$pip_cache"
args="$args --bind $VENV/cache $home/.cache"
args="$args --bind $pip_cache $home/.cache/pip"

# Pass our own redacted copy of env
for var in $(env | grep -E '^(USER|SHLVL|SHELL|TERM|LANG|LC_.*)$'); do
    args="$args --setenv $(echo "$var" | tr '=' ' ')"
done

set $xtrace
chdir="$(realpath --relative-to "$VENV/.." "$(pwd)")"
chdir="$home/${chdir#"$(realpath "$VENV/..")"}"

format_args () { for arg in "$@"; do case "$arg" in *\ *) printf "'%s' " "$arg" ;; *) printf "%s " "$arg" ;; esac; done; }
warn "exec bwrap $(realpath "$VENV/bin/$EXECUTABLE") $(format_args "$@")"

# NOTE: Pass $args last
# shellcheck disable=SC2086
exec bwrap \
    --dir /tmp \
    --dir "/run/user/$(id -u)" \
    --proc /proc \
    --dev /dev \
    --chdir "$chdir" \
    --clearenv \
    --unshare-all \
    --share-net \
    --new-session \
    --die-with-parent \
    --setenv PS1 '\u @ \h \$' \
    --setenv HOME "$home" \
    --setenv USER "${home##*/}" \
    --setenv VIRTUAL_ENV "$home/${VENV##*/}" \
    $args \
    $_BWRAP_DEFAULT_ARGS \
    ${BWRAP_ARGS:-} \
    "$home/${VENV##*/}/bin/$EXECUTABLE" "$@"
